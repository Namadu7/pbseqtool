from cmdReference import CmdReference
import struct

valid_game_names = ("XY", "ORAS", "SM", "USUM", "LGPE", "SwSh", "BDSP")
game_version = {"XY": 2, "ORAS": 2, "SM": 3, "USUM": 3, "LGPE": 3,
                "SwSh": 4, "BDSP": -1}
num_grp_options = {"XY": 1, "ORAS": 1, "SM": 2, "USUM": 2, "LGPE": 2,
                "SwSh": 32, "BDSP": 38}





class Cmd:

    error_str = {"nameStartEnd":
                 "This command is lacking either a Name, a StartFrame,\n"+
                 "or an EndFrame.\n",

                 "nameString":
                 "Name should be a string.\n",

                 "frameInt":
                 "StartFrame and EndFrame should both be integers.\n",

                 "frameBackwards":
                 "EndFrame should be greater than or equal to StartFrame;\n"+
                 "a command can't end before it starts!\n",

                 "frameNegative":
                 "StartFrame and EndFrame cannot be negative.\n",

                 "paramObj":
                 "\"Parameters\" should be an object.\n",

                 "notACommand":
                 "\"{cmd}\" is not a command name in {game}.\n",

                 "notAParam":
                 "\"{param}\" isn't a known parameter name for this command.\n",

                 "commandPrefix":
                 "In the command {cmd} from frame {start} to frame {end}:\n",
                 
                 "notAHex":
                 "Param \"{param}\" expects a hex string for its value;\n"+
                 "that is, a pair of \"quotation marks\" around some text,\n"+
                 "the only valid characters being 0123456789ABCDEF.\n",

                 "hexBadLength":
                 "Param \"{param}\" should have a value that's\n"+
                 "exactly {length} bytes, or {length2} characters, long.\n",

                 "notAString":
                 "Param \"{param}\" expects a string for its value;\n"+
                 "that is, a pair of \"quotation marks\" around some text.\n",

                 "stringBadLength":
                 "Param \"{param}\" was given too long a value;\n"+
                 "it should be no more than {length} characters long.\n",

                 "notAFloat":
                 "Param \"{param}\" expects a float for its value;\n"+
                 "that is, a number ending with a decimal portion.\n"+
                 "For example, 10.0, 0.5, or -13.894.\n",

                 "notAnInt":
                 "Param \"{param}\" expects an integer for its value;\n"+
                 "that is, a number without a decimal portion.\n"+
                 "For example, 0, 30, or -99.\n",                     

                 "notABool":
                 "Param \"{param}\" expects a bool for its value;\n"+
                 "that is, a 0 or 1.\n",       

                 "notAListFloat":
                 "Param \"{param}\" expects a list of exactly 3 floats;\n"+
                 "that is, numbers ending with decimal portions.\n"+
                 "For example, 10.0, 0.5, or -13.894.\n",

                 "notAListInt":
                 "Param \"{param}\" expects a list of exactly 3 integers;\n"+
                 "that is, numbers without decimal portions.\n"+
                 "For example, 0, 30, or -99.\n",

                 "notAListBool":
                 "Param \"{param}\" expects a list of exactly 3 bools;\n"+
                 "that is, all of them being either 0 or 1.\n",
                 
                 "notAnUnknown":
                 "Param \"{param}\" has an unknown value type,\n"+
                 "but you still need to give it an int, float, or string.\n"
                }
    
    def __init__(self, cmd_id: str, opts: dict, args: dict,
                 byte_length: int, ref: CmdReference):
        self.id = cmd_id
        self.name = ref.id_to_name(cmd_id)
        # Options refer to the parameters shared by all commands.
        self.opts = opts
        # Args are parameter values specific to a particular kind of command.
        self.args = args
        self.byte_length = byte_length

        # We'll make these three options easier to access.
        self.start_frame = self.opts["StartFrame"]
        self.end_frame = self.opts["EndFrame"]
        self.group_num = self.opts["GrpNo"]

        # Just in case we need to look something up later...
        self.ref = ref

    @classmethod
    def from_dict(cls, cmd_dict: dict, group_options: dict, ref: CmdReference):
        """
        Constructs a Cmd object from a .json-sourced dictionary.
        Currently only supports "simple" .json files generated by this program.
        
        :param cmd_dict: The command object from the .json file.
        :param group_options: The command's GroupOptions object.
        :param ref: The command reference for this game.

        :return: This Cmd object.
        """

        opts = {}
        args = {}
        game = ref.game
        


        # First, copy over the group options. TODO: are these needed...?
        for opt in group_options:
            opts[opt] = group_options[opt]


        # Next, let's grab the name, StartFrame, and EndFrame.
        try:
            cmd_name = cmd_dict["Name"]
            start_frame = cmd_dict["StartFrame"]
            end_frame = cmd_dict["EndFrame"]

        # Are any of them missing? 
        except KeyError:
            curr_error = Cmd.error_str["nameStartEnd"]
            raise ValueError(curr_error)

        # Is the name actually a string? 
        if not isinstance(cmd_name,str):
            try:
                cmd_name = str(cmd_name)
            except (TypeError, ValueError):
                curr_error = Cmd.error_str["nameString"]
                raise ValueError(curr_error)

        # Are the frames actually ints?         
        if (not isinstance(start_frame,int) or
            not isinstance(end_frame,int)):
            try:
                start_frame = int(start_frame)
                end_frame = int(end_frame)
            except (TypeError, ValueError):
                curr_error = Cmd.error_str["frameInt"]
                raise ValueError(curr_error)

        # Now that we know these are valid,
        # let's use that for future error messages if needed.

        curr_error = Cmd.error_str["commandPrefix"]
        curr_error = curr_error.replace("{cmd}",cmd_name)
        curr_error = curr_error.replace("{start}",str(start_frame))
        curr_error = curr_error.replace("{end}",str(end_frame))        

        # Is the start or end frame negative?
        if start_frame < 0 or end_frame < 0:
            curr_error += Cmd.error_str["frameNegative"]
            raise ValueError(curr_error)

        # Do the start & end frames make chronological sense?
        if end_frame < start_frame:
            curr_error += Cmd.error_str["frameBackwards"]
            raise ValueError(curr_error)        
        
        opts["StartFrame"] = start_frame
        opts["EndFrame"] = end_frame

        # Let's also make sure there's a dictionary of parameters/arguments.
        try:
            input_args = cmd_dict["Parameters"]
        except KeyError:
            input_args = {}

        if not isinstance(input_args,dict):
            curr_error += Cmd.error_str["paramObj"]
            raise ValueError(curr_error)

        # Now let's look up info about this command... if it's valid.
        try:
            cmd_id = ref.name_to_id(cmd_name)
        except KeyError:
            curr_error += Cmd.error_str["notACommand"]
            curr_error = curr_error.replace("{cmd}",cmd_name)
            curr_error = curr_error.replace("{game}",game)
            raise ValueError(curr_error)



        byte_length = ref.params_length(cmd_id)
        
        param_refs = ref.lookup_params(cmd_id)


        # First off, let's just check that all the param names are valid.
        valid_param_names = set()
        for param_ref in param_refs:
            for name in param_ref.names:
                valid_param_names.add(name)

        for arg in input_args:
            if arg not in valid_param_names:
                curr_error += Cmd.error_str["notAParam"]
                curr_error = curr_error.replace("{param}",arg)
                raise ValueError(curr_error)

        # The bulk of the info is in the ParamRef objects.
        for param_ref in param_refs:
            # We'll use these to look for param values, one by one.
            first_name = param_ref.names[0]
            args[first_name] = param_ref.default

            # We don't want to assume that the user chose the first param name.
            # It could be any of them!
            # (Or multiple of them, in which case we just take the last one.)
            # TODO: make this more time-efficient. It retreads a lot of ground.
            for name in param_ref.names:
                if name in input_args:
                    # Hey, it's a match! But before we add it, is the value OK?
                    
                    value = input_args[name]
                    value_type = param_ref.value_type
                    param_length = param_ref.length

                    if value_type == "Hex":
                        # Is it actually a hex string?
                        try:
                            canitbyte = bytes.fromhex(value)
                        except (ValueError, TypeError):
                            curr_error += Cmd.error_str["notAHex"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)

                        # Is it the right length?
                        # Note: 1 byte translates to 2 chars in a hexstring.
                        if len(value) != param_length*2:
                            curr_error += Cmd.error_str["hexBadLength"]
                            curr_error = curr_error.replace("{param}",name)
                            curr_error = curr_error.replace("{length}",
                                                            str(param_length))
                            curr_error = curr_error.replace("{length2}",
                                                            str(2*param_length))
                            raise ValueError(curr_error)

              
                        
                    elif value_type == "String" or (value_type == "Unknown" and
                                                    isinstance(value,str)):
                        # Is it actually a string?
                        if not isinstance(value,str):
                            curr_error += Cmd.error_str["notAString"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)

                        # Is it too long?
                        if len(value) > param_length:
                            curr_error += Cmd.error_str["stringBadLength"]
                            curr_error = curr_error.replace("{param}",name)
                            curr_error = curr_error.replace("{length}",
                                                            str(param_length))
                            raise ValueError(curr_error)                   



                    elif value_type == "Float" or (value_type == "Unknown" and
                                                   isinstance(value,float)):
                        # If it's an int, make it a float.
                        if isinstance(value,int):
                            value = float(value)

                        # Is it actually a float?
                        if not isinstance(value,float):
                            curr_error += Cmd.error_str["notAFloat"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)                        



                    elif value_type == "Int" or (value_type == "Unknown" and
                                                 isinstance(value,int)):
                        # Is it actually an int?
                        if not isinstance(value,int):
                            curr_error += Cmd.error_str["notAnInt"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)       



                    elif value_type == "Bool":
                        # Is it actually a bool?
                        if value not in (0,1):
                            curr_error += Cmd.error_str["notABool"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)       



                    elif value_type == "ListFloat":
                        # Is it actually a list of 3 values?
                        if not isinstance(value,list) or len(value) != 3:
                            curr_error += Cmd.error_str["notAListFloat"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)       

                        # Are those 3 values all floats? (Or ints?)
                        # If it's an int, make it a float.
                        for element in value:
                            if isinstance(element,int):
                                element = float(element)
                                
                            if not isinstance(element,float):
                                curr_error += Cmd.error_str["notAListFloat"]
                                curr_error = curr_error.replace("{param}",name)
                                raise ValueError(curr_error)                               



                    elif value_type == "ListInt":
                        # Is it actually a list of 3 values?
                        if not isinstance(value,list) or len(value) != 3:
                            curr_error += Cmd.error_str["notAListInt"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)
                        
                        # Are those 3 values all ints?
                        for element in value:
                            if not isinstance(element,int):
                                curr_error += Cmd.error_str["notAListInt"]
                                curr_error = curr_error.replace("{param}",name)
                                raise ValueError(curr_error) 



                    elif value_type == "ListBool":
                        # Is it actually a list of 3 values?
                        if not isinstance(value,list) or len(value) != 3:
                            curr_error += Cmd.error_str["notAListBool"]
                            curr_error = curr_error.replace("{param}",name)
                            raise ValueError(curr_error)
                        
                        # Are those 3 values all bools?
                        for element in value:
                            if element not in (0,1):
                                curr_error += Cmd.error_str["notAListBool"]
                                curr_error = curr_error.replace("{param}",name)
                                raise ValueError(curr_error)

                            
                    else:
                        # If we got to this point, it must be Unknown,
                        # and we got something other than a float, int, or string.
                        curr_error += Cmd.error_str["notAnUnknown"]
                        curr_error = curr_error.replace("{name}",name)
                        raise ValueError(curr_error)


                    # Well, if we got to this point, the value's good to go!
                    args[first_name] = value


        cmd = cls(cmd_id, opts, args, byte_length, ref)
        return cmd
    

    @classmethod
    def from_bytes(cls, cmd_bytes: bytes, offset: int, ref: CmdReference):
        """
        Constructs a Cmd object from bytes from a .bseq file.
        
        :param cmd_bytes: The bytestring.
        :param offset: Where in the bytestring this command starts.
        :param ref: The command reference for this game.
        
        :return: This Cmd object.
        """

        game = ref.game
        version = game_version[game]

        opts_bytes = {}
        opts = {}
        args_bytes = {}
        args = {}

        crsr = offset

        # First we grab the params common to all commands.
        # This format varies across SESD versions.
        if version == 2:
            opts_bytes["StartFrame"] = cmd_bytes[offset:offset + 4]
            opts_bytes["EndFrame"] = cmd_bytes[offset + 4:offset + 8]
            opts_bytes["GrpNo"] = cmd_bytes[offset + 8:offset + 10]
            opts_bytes["Option0"] = cmd_bytes[offset + 10:offset + 12]
            cmd_id_bytes = cmd_bytes[offset + 12:offset + 14]
            cmd_id = cmd_id_bytes.hex().upper()

            crsr += 14

            # Now convert those to ints.
            for opt_key in opts_bytes:
                opts[opt_key] = int.from_bytes(opts_bytes[opt_key], "little")

        elif version == 3:
            opts_bytes["StartFrame"] = cmd_bytes[offset:offset + 4]
            opts_bytes["EndFrame"] = cmd_bytes[offset + 4:offset + 8]
            opts_bytes["GrpNo"] = cmd_bytes[offset + 8:offset + 10]
            opts_bytes["Option0"] = cmd_bytes[offset + 10:offset + 12]
            opts_bytes["Option1"] = cmd_bytes[offset + 12:offset + 14]
            cmd_id_bytes = cmd_bytes[offset + 14:offset + 16]
            cmd_id = cmd_id_bytes.hex().upper()

            crsr += 16

            # Now convert those to ints.
            
            for opt_key in opts_bytes:
                opts[opt_key] = int.from_bytes(opts_bytes[opt_key], "little")


        elif version == 4:
            opts_bytes["StartFrame"] = cmd_bytes[offset:offset + 4]
            opts_bytes["EndFrame"] = cmd_bytes[offset + 4:offset + 8]
            opts_bytes["GrpNo"] = cmd_bytes[offset + 8:offset + 12]

            # Now we grab the 32 group options...
            # TODO: once you figure out non-battle sequences,
            # change this 32 to no longer be a magic number!
            crsr += 12
            for i in range(32):
                option_value_bytes = cmd_bytes[crsr + 8:crsr + 12]
                option_name = "Option" + str(i)
                opts_bytes[option_name] = option_value_bytes

                crsr += 12

            # Now convert those to ints.
            for opt_key in opts_bytes:
                opts[opt_key] = int.from_bytes(opts_bytes[opt_key], "little")

            cmd_id_bytes = cmd_bytes[crsr:crsr + 8]
            cmd_id = cmd_id_bytes.hex().upper()

            crsr += 8

        else:
            raise ValueError("Version number not currently supported.\n")

        # Next we grab the command-specific arguments.
        param_list = ref.lookup_params(cmd_id)

        for param in param_list:
            arg_bytes = cmd_bytes[crsr:crsr + param.length]
            
            if param.value_type == "Hex":
                arg = arg_bytes.hex()
                
            elif param.value_type == "String":
                arg = arg_bytes.decode("UTF-8").strip("\0")
                
            elif param.value_type == "Float":
                arg = struct.unpack('f', arg_bytes)[0]
                arg = round(arg,8)
                    
            elif param.value_type in ("Int", "Bool"):
                arg = int.from_bytes(arg_bytes, "little", signed=True)

            elif param.value_type == "ListFloat":
                arg = []
                for i in range(param.length // 4):
                    float_bytes = arg_bytes[i * 4:(i * 4) + 4]
                    float_real = struct.unpack('f', float_bytes)[0]
                    float_real = round(float_real,8)
                    arg.append(float_real)
                
            elif param.value_type in ("ListInt", "ListBool"):
                arg = []
                for i in range(param.length // 4):
                    int_bytes = arg_bytes[i * 4:(i * 4) + 4]
                    int_real = int.from_bytes(int_bytes, "little", signed=True)
                    arg.append(int_real)
                    
            elif param.value_type == "Unknown":
                # Just assume it's an int, for now.
                arg = int.from_bytes(arg_bytes, "little", signed=True)
            else:
                error = "Unrecognized param value type "
                error += f"\"{param.value_type}\"!\n"
                raise ValueError(error)

            args[param.names[0]] = arg

            crsr += param.length

        byte_length = crsr - offset

        cmd = cls(cmd_id, opts, args, byte_length, ref)
        return cmd



    def to_bytes(self, ref: CmdReference):
        """
        Returns a bytes object intended to be written
        as part of a bseq file.
         
        :return: A bytestring for this command,
                 ready to be included in a .bseq file.
        """

        version = game_version[ref.game]
        

        # The first 12 bytes of a command are always the same. 4 bytes each:
        # - The start frame.
        # - The end frame.
        # - The group number.
        
        bseq_bytes = bytearray()
        bseq_bytes += self.start_frame.to_bytes(4,"little")
        bseq_bytes += self.end_frame.to_bytes(4,"little")
        if version == 4:
            bseq_bytes += self.group_num.to_bytes(4,"little")
        else:
            bseq_bytes += self.group_num.to_bytes(2,"little")

        # Next we print the group options...
        # In SwSh they're different than in all previous games.

        if version == 4:

            # For some reason, each option is printed as...
            # first, an 8-byte identifier for that option;
            # then, a 4-byte int for that option's value.
            # And there are 33 options. It gets messy.

            option_ids = ref.group_option_ids
            for i in range(num_grp_options[ref.game]):

                # Converting & outputting the ID...
                option_id_hex = option_ids[i]
                option_id_bytes = bytes.fromhex(option_id_hex)
                bseq_bytes += option_id_bytes

                # ...and the value.
                option_name = "Option" + str(i)
                if option_name in self.opts:
                    option = self.opts[option_name]
                else:
                    option = 0

                bseq_bytes += option.to_bytes(4,"little")


        # In the earlier games, each is just printed as a 2-byte int.
        elif version == 2:
            bseq_bytes += self.opts["Option0"].to_bytes(2,"little")
            
        elif version == 3:
            bseq_bytes += self.opts["Option0"].to_bytes(2,"little")
            bseq_bytes += self.opts["Option1"].to_bytes(2,"little")


        # Aaaaand finally, the command "ID" itself.

        bseq_bytes += bytes.fromhex(self.id)
        
        # Okay! Now the command-specific params.
        # At this point, we'll assume that all params have valid values.
        # The read methods will have the validation.

        param_list = ref.lookup_params(self.id)

        for param in param_list:
            arg = self.args[param.names[0]]
            
            if param.value_type == "Hex":
                arg_bytes = bytes.fromhex(arg)
                # A hexstring needs to be the correct number of bytes, too.
                # So we add 00 bytes to the end if needed.
                if len(arg_bytes) < param.length:
                    pad_bytes_num = param.length - len(arg_bytes)
                    arg_bytes += b"\x00"*pad_bytes_num                
                
            elif param.value_type == "String" or (param.value_type == "Unknown" and
                                                  isinstance(arg,str)):
                arg_bytes = bytes(arg,"UTF-8")
                # A string needs to be the correct number of bytes, too.
                # So we add 00 bytes to the end if needed.
                if len(arg_bytes) < param.length:
                    pad_bytes_num = param.length - len(arg_bytes)
                    arg_bytes += b"\x00"*pad_bytes_num

            elif param.value_type == "Float" or (param.value_type == "Unknown" and
                                                 isinstance(arg,float)):
                arg_bytes = struct.pack('f', arg)

            elif param.value_type in ("Int", "Bool") or (param.value_type == "Unknown" and
                                                         isinstance(arg,int)):
                arg_bytes = arg.to_bytes(param.length, 'little',
                                         signed=True)

            elif param.value_type == "ListFloat":
                arg_bytes = bytearray()
                for i in range(param.length//4):
                    arg_bytes += struct.pack('f', arg[i])

            elif param.value_type in ("ListInt", "ListBool"):
                arg_bytes = bytearray()
                for i in range(param.length//4):
                    arg_bytes += arg[i].to_bytes(4, 'little',
                                                 signed=True)

            else:
                error = "Unrecognized param value type for an Unknown param!"
                error += "\nThis should have been caught during construction!\n"
                raise ValueError(error)
                
            bseq_bytes += arg_bytes

        # And that's it!
        return bseq_bytes
            
            
    def get_group_num(self):
        return self.opts["GrpNo"]

    def __lt__(self, other):
        return self.start_frame < other.start_frame

class CmdGroup:
    def __init__(self, num: int, options: dict):
        self.num = num
        self.options = {}
        self.commands = []

        for option in options:
            if option not in ("StartFrame", "EndFrame"):
                value = options[option]
                self.options[option] = value

    def does_match_command(self, cmd: Cmd):
        """
        Verifies whether a command's "group options" match this group.
        
        :param cmd: A command to check against this group.
        
        :return: False if any of the command's options' values mismatch
                 the corresponding option in this group. True otherwise.
        """

        # First thing first, check the group number.
        if "GrpNo" in cmd.opts and cmd.opts["GrpNo"] != self.num:
            return False

        # There might be multiple same-numbered groups. Is this *the* one?
        for key in cmd.opts:
            if key in self.options:
                if cmd.opts[key] != self.options[key]:
                    return False

        return True

    def add_command(self, cmd: Cmd):
        self.commands.append(cmd)

    def num_commands(self):
        return len(self.commands)

    def __lt__(self, other):
        return self.num < other.num


class SESD:


    def __init__(self, num_frames: int, cmd_groups: list, game: str, ref: CmdReference):
        """
        Create an SESD object from a .bseq-sourced bytestring.
        
        :param bseq_bytes: A bytestring to represent a single sequence.
        :param game: A string representing this SESD's game.
        :param ref: The command reference to use for this sequence.
        
        :return: None.
        """
        
        self.num_frames = num_frames
        self.cmd_groups = cmd_groups
        self.game = game
        self.ref = ref

    @classmethod
    def from_dict(cls, json_dict: dict, game: str, ref: CmdReference):
        """
        Constructs an SESD object from a .json-sourced dictionary.
        Currently only supports "simple" .json files generated by this program.

        :param bseq_dict: The command object from the .json file.
        :param game: A string representing the SESD's game. Redundant; validator.
        :param ref: The command reference for this game.

        :return: This SESD object.
        """

        cmd_groups = []

        num_frames = 0 

        # Let's first validate the game name...
        if game != ref.game:
            error = "Given CmdReference is for the wrong game; \nthe given SESD"
            error += f"is for {game} but the reference is for {ref.game}!\n"
            raise ValueError(error)

        if game not in valid_game_names:
            if isinstance(game, str):
                raise ValueError(f"Invalid game name given: {game}\n")
            else:
                raise ValueError("Invalid game name given; should be a string.\n")

            
        # We'll read through the bseq_dict with two goals in mind.
        #  1. Ensure the data is actually a valid bseq; raise error if not.
        #  2. Assuming it is, use relevant data to create the SESD instance.


        # First: does this file's game match?
        try:
            json_game = json_dict["Metadata"]["Game"]
        except KeyError:
            raise ValueError("Couldn't find the game specified in Metadata object.\n")

        if json_game != game:
            error = "Given .json file is for the wrong game!"
            error += f"\nIt's for {json_game}, but {game} was expected.\n"
            raise ValueError(error)

        # Next: is there a data list?

        try:
            data_dict = json_dict["Data"]
        except KeyError:
            raise ValueError("No list \"Data\" found in the base object.\n")

        if not isinstance(data_dict,list):
            raise ValueError("\"Data\" was not a list as expected.\n")

        # Now let's try to get the list of groups from Data.

        for i,group in enumerate(data_dict):
            if not isinstance(group,dict):
                raise ValueError("\"Data\" contained something that's not an object.\n")

            try:
                grp_num = group["GrpNo"]
                group_options = group["GroupOptions"]

                if (not isinstance(grp_num,int) or
                    not isinstance(group_options,dict)):
                    raise KeyError()
                
            except KeyError:
                raise ValueError(f"Group #{i+1} from the top of the file\n" +
                                 "was lacking either a \"GrpNo\" integer " +
                                 "or a \"GroupOptions\" object.\n")


            # Let's make sure the GroupOptions also make sense.
            # The keys should all be "Option0", "Option1", etc.
            # The max number depends on the game.            

            # TODO: this validation should be part of the CmdGroup class!
            max_grp_opt = num_grp_options[game]
            
            for option in group_options:
                
                # First, is the option name valid? (Option0, Option1, etc)
                value = group_options[option]
                try:
                    if "Option" not in option:
                        raise ValueError
                    option_num_str = option.replace("Option","")
                    opt_num = int(option_num_str)
                except ValueError:
                    raise ValueError(f"In a group with GrpNo {grp_num},\n"+
                                     f"there's a GroupOption named {option},"+
                                     "but option names should be \"Option##\".\n")
                
                # Next, is the option number valid in this game?
                if opt_num < 0 or opt_num >= max_grp_opt:
                    raise ValueError(f"In a group with GrpNo {grp_num},\n"+
                                     "there's a GroupOption named {option},"+
                                     "but the max option number for {game} is {max_grp_opt}.\n")

                # Finally, is the value an integer?
                if not isinstance(value,int):
                    raise ValueError(f"In a group with GrpNo {grp_num},\n"+
                                     "the GroupOption named {option}"+
                                     "should only have an integer value.)\n")



            # Let's also make sure *all* options are represented,
            # giving them values of 0 if they weren't specified in the JSON.

            for i in range(max_grp_opt):
                opt_name = "Option" + str(i)
                if opt_name not in group_options:
                    group_options[opt_name] = 0

            group_obj = CmdGroup(grp_num, group_options)

            # TODO: this probably isn't ultimately needed for the Cmd object.
            group_options["GrpNo"] = grp_num

            # Okay, so we're definitely looking at a group.
            # We've also made an object for it.
            # Next is the list of commands in that group...

            for j,cmd_dict in enumerate(group["Commands"]): 
                if not isinstance(cmd_dict,dict):
                    raise ValueError(f"Command #{j+1} from the top of the group\n" +
                                     f"with GrpNo {grp_num} is not an object!\n")

                # We can just let the Cmd.from_dict method handle THAT.
                try:
                    cmd_obj = Cmd.from_dict(cmd_dict, group_options, ref)
                    
                except (ValueError, TypeError) as e:
                    error_str = (f"In the group that's #{i+1} from the top "+
                                 f"of the file (with GrpNo {grp_num}):\n")
                    if "In the command" not in e.args[0]:
                        error_str += f"In command #{j+1} from the top of the group:\n"
                    raise ValueError(error_str + e.args[0])
                                 
                
                group_obj.add_command(cmd_obj)

                num_frames = max(num_frames, cmd_obj.end_frame)

            cmd_groups.append(group_obj)

        # Now we have all the commands, sorted into their groups!
        # Let's sort them by group number real quick.
        cmd_groups.sort()

        # Now we have everything we need to create the instance!
        sesd = cls(num_frames, cmd_groups, game, ref)
        return sesd
        

    @classmethod
    def from_bytes(cls, bseq_bytes: bytes, game: str, ref: CmdReference):
        """
        Constructs an SESD object from bytes from a .bseq file.
        Currently only supports "simple" .json files generated by this program.

        :param bseq_bytes: The bytestring.
        :param game: A string representing the SESD's game. Redundant; validator.
        :param ref: The command reference for this game.

        :return: This SESD object.
        """

        cmd_groups = []

        # Let's quickly validate the game name...
        if game != ref.game:
            error = "Given CmdReference is for the wrong game; \nthe given SESD"
            error += f"is for {game} but the reference is for {ref.game}!\n"
            raise ValueError(error)

        if game not in valid_game_names:
            if isinstance(game, str):
                raise ValueError(f"Invalid game name given: {game}\n")
            else:
                raise ValueError("Invalid game name given; should be a string.\n")

        # We'll scan through the bseq_bytes with two goals in mind.
        #  1. Ensure the data is actually a valid bseq; raise error if not.
        #  2. Assuming it is, use relevant data to create the SESD instance.

        if bseq_bytes[0:4] != bytes.fromhex("53455344"):
            raise ValueError("BSEQ file doesn't start with SESD as expected.\n")

        expected_version = game_version[game]

        if expected_version == -1:
            raise ValueError("SESD parsing not supported for this game.\n")

        version_bytes = bseq_bytes[4:8]
        version = int.from_bytes(version_bytes, "little")
        if version != expected_version:
            error = f"BSEQ file version is {str(version)}, but expected "
            error += f"version {str(expected_version)} for this game.\n"
            raise ValueError(error)

        num_frames_bytes = bseq_bytes[12:16]
        num_frames = int.from_bytes(num_frames_bytes, "little")

        crsr = 16

        if game == "SwSh":
            # Skip the list of command types & their param lengths at the start.
            num_commands_bytes = bseq_bytes[20:24]
            num_commands = int.from_bytes(num_commands_bytes, "little")
            crsr += 8 + (12 * num_commands)

        # Now we're at the start of the list of actual commands.

        while crsr < len(bseq_bytes) + 4:

            # FFFFFFFF marks the end of the SESD.
            if bseq_bytes[crsr:crsr + 4] == bytes.fromhex("FFFFFFFF"):
                break

            # If we're not there yet, we have a command to read in.
            try:
                new_cmd = Cmd.from_bytes(bseq_bytes, crsr, ref)
            except (ValueError, TypeError) as e:
                error_str = (f"In the group that's #{i+1} from the top "+
                             f"of the file (with GrpNo {grp_num}):\n")
                raise ValueError(error_str + e.args[0])
            group_num = new_cmd.get_group_num()

            # Now we add that command to its numbered group.
            # We'll make that group if it doesn't already exist.
            # Since there might exist multiple same-numbered groups
            # with different group options, we can't just add commands
            # to the same-numbered group; we need to check that the group's
            # other options match with the command, too.
            found = False
            for group in cmd_groups:
                if group.does_match_command(new_cmd):
                    group.add_command(new_cmd)
                    found = True
            if not found:
                new_group = CmdGroup(group_num, new_cmd.opts)
                new_group.add_command(new_cmd)
                cmd_groups.append(new_group)

            # Either way, move the cursor forward!
            crsr += new_cmd.byte_length

        # Now we have all the commands, sorted into their groups!
        # Let's sort them by group number real quick.
        cmd_groups.sort()

        # Now we have everything we need to create the instance!
        sesd = cls(num_frames, cmd_groups, game, ref)
        return sesd

        

    def get_bseq(self):
        """
        Returns a bytes object intended to be written
        as a bseq file.
                        
        :return: A bytestring ready to be dumped as a .bseq file.
        """        

        # The first 16 bytes are (4 bytes each):
        # - "SESD",
        # - the version number,
        # - 00000000,
        # - the total number of frames.
        bseq_bytes = bytearray()
        bseq_bytes += b"SESD"

        version_int = game_version[self.game]
        version_bytes = version_int.to_bytes(4,"little")
        bseq_bytes += version_bytes

        bseq_bytes += b"\x00\x00\x00\x00"

        frames_bytes = self.num_frames.to_bytes(4,"little")
        bseq_bytes += frames_bytes

        # If we're in SwSh, there's a whole buncha other junk
        # before the move itself.

        if self.game == "SwSh":
            # I dunno what exactly this 32 (0x20) is about...
            bseq_bytes += b"\x20\x00\x00\x00"

            # But this is the number of commands in the game.
            bseq_bytes += b"\x81\x01\x00\x00"

            # And now a list of every command type's ID,
            # plus its total byte length of params.

            for cmd_id in self.ref.commands:
                cmd_def = self.ref.commands[cmd_id]
                
                cmd_id_bytes = bytes.fromhex(cmd_def.id)
                bseq_bytes += cmd_id_bytes

                cmd_param_bytes_int = cmd_def.param_bytes
                cmd_param_bytes_bytes = cmd_param_bytes_int.to_bytes(4,"little")
                bseq_bytes += cmd_param_bytes_bytes  # Sorry for this name...


        # Hurrah! We made it to the actual list of commands for this sequence!
        # In a BSEQ, commands need to be in chronological order by start frame.
        # So let's get the commands out of their groups and into a list.

        cmd_list = []
        for group in self.cmd_groups:
            for command in group.commands:
                cmd_list.append(command)

        # Since commands are compared by start frame,
        # the sort method should work just fine with a list of them.
        
        cmd_list.sort()

        # ...and now we gotta actually print them.
        for cmd in cmd_list:
            bseq_bytes += cmd.to_bytes(self.ref)


        # After all the commands, all that's left is FFFFFFFF.

        bseq_bytes += b"\xFF\xFF\xFF\xFF"

        # XY and ORAS would want their file lengths to be a multiple of 4,
        # but the GARC methods will handle that.

        # Hooray!
        return bseq_bytes
        
        




    def get_json_dict_simple(self, seq_name="", opts_setting=1):
        """
        Returns a dict object intended to be dumped as a .json file
        that's easy to edit and convert back to a .bseq file.

        :param seq_name: The name of the sequence. Not a big deal.

        :param opts_setting : If 0, no group options are output.
                              If 1, only nonzero group options are output.
                              If 2, all will be output.
                        
        :return:         A dict object ready to be dumped as a .json file.
        """        

        output_dict = {}



        ###################################
        #       Simple JSON format        #
        ###################################
        metadata_dict = {}
        
        metadata_dict["Game"] = self.game
        metadata_dict["Name"] = seq_name
        metadata_dict["Description"] = ""
        
        output_dict["Metadata"] = metadata_dict

        
        group_data = []
        
        for group in self.cmd_groups:
            if group.num_commands() > 0:

                
                
                group_dict = {"GrpNo": group.num, "GroupOptions": {} }

                # Okay, now let's grab all the group options...
                first_cmd = group.commands[0]
                if opts_setting != 0:
                    for opt in first_cmd.opts:
                        if (opt[0:6] == "Option" and
                            (first_cmd.opts[opt] != 0 or opts_setting == 2)):
                            group_dict["GroupOptions"][opt] = first_cmd.opts[opt]

                # And now the actual commands.
                group_dict["Commands"] = []

                for cmd in group.commands:

                    # TODO: this Cmd -> dict stuff should be a Cmd method!
                    
                    start_frame = cmd.opts["StartFrame"]
                    end_frame = cmd.opts["EndFrame"]
                        
                    new_cmd_dict = {"Name": cmd.name,
                                    "StartFrame": start_frame,
                                    "EndFrame": end_frame}                    
                    


                    new_cmd_values = {}

                    for arg in cmd.args:
                        if arg not in ("StartFrame", "EndFrame"):
                            
                            if isinstance(cmd.args[arg], list):
                                new_cmd_values[arg] = [v for v in cmd.args[arg]]
                            else:
                                new_cmd_values[arg] = cmd.args[arg]

                    new_cmd_dict["Parameters"] = new_cmd_values

                    group_dict["Commands"].append(new_cmd_dict)
                    
                group_data.append(group_dict)


        output_dict["Data"] = group_data
            
        return output_dict

    def get_json_dict_bdsp(self, bdsp_ref, seq_name="", opts_setting=1,
                           uabea=False, warns_setting=2):
        """
        Returns a dict object intended to be dumped as a .json file
        that can be imported into BDSP.

        :param bdsp_ref: A CmdReference object generated from
                         BDSPCommandReference.

        :param seq_name: The name of the sequence. Not a big deal.

        :param opts_setting : If 0, no group options are output.
                              If 1, only nonzero group options are output.
                              If 2, all will be output.
                        
        :param uabea:    This specifies the JSON format.
                           If UABEA is true, it'll be in the format UABEA uses.
                           Otherwise, it'll be in the format Aldo's tool uses.

        :param warns_setting : If 0, no warnings are output.
                               If 1, warnings are output as just "WARNING".
                               If 2, warnings are output with suggested fix.
                        
        :return:         A dict object ready to be dumped as a .json file.
        """

        # Params that need to be halved going from LGPE/SwSh to BDSP.
        frame_params = {"start1", "end1", "start2", "end2", "start3", "end3",
                        "start4", "end4", "start5", "end5", "start6", "end6",
                        "frame1", "frame2", "frame3", "frame4", "frame5",
                        "frame"}

        output_dict = {}



        ###################################
        #        UABEA JSON format        #
        ###################################
        if uabea:
            
            game_object_dict = {"m_FileID": 0, "m_PathID": 0}
            output_dict["m_GameObject"] = game_object_dict
            output_dict["m_Enabled"] = 1

            script_dict = {"m_FileID": 0, "m_PathID": 8754883562377533094}
            output_dict["m_Script"] = script_dict

            output_dict["m_Name"] = seq_name
            group_data = {"Array": []}
            
            for group in self.cmd_groups:
                if group.num_commands() > 0:

                    group_dict = {"Name": "", "GrpNo": group.num, "IsOpen": 1,
                                  "GrpDebug": 0, "BgColR": 0, "BgColG": 0, "BgColB": 0,
                                  "ColR": 0, "ColG": 0, "ColB": 0, "GrpOption": "",
                                  "GroupOption": {"Array": []} }

                    # Okay, now let's grab all the group options...
                    first_cmd = group.commands[0]
                    if opts_setting != 0:
                        for opt in first_cmd.opts:
                            if (opt[0:6] == "Option" and
                                (first_cmd.opts[opt] != 0 or opts_setting == 2)):
                                new_opt_dict = {}
                                num = int(opt[6:].strip())
                                new_opt_dict["Option"] = num
                                new_opt_dict["Value"] = first_cmd.opts[opt]
                                group_dict["GroupOption"]["Array"].append(new_opt_dict)

                    # And now the actual commands.
                    group_dict["Commands"] = {"Array": []}

                    for cmd in group.commands:

                        # TODO: this Cmd -> dict stuff should be a Cmd method!
                        
                        start_frame = cmd.opts["StartFrame"]
                        end_frame = cmd.opts["EndFrame"]

                        # LGPE and SwSh frame values are based on 60 FPS,
                        # but BDSP frame values are based on 30 FPS.
                        if self.game in ("SwSh, LGPE"):
                            start_frame = round(start_frame/2)
                            end_frame = round(end_frame/2)
                            
                        new_cmd_dict = {"StartFrame": start_frame,
                                        "EndFrame": end_frame,
                                        "ColR": 0, "ColG": 0, "ColB": 0,
                                        "Comment": "", "IsActive": 1}
                        
                        new_name = cmd.name.replace("Orion", "Old")

                        
                        
                        try:
                            cmd_id = bdsp_ref.name_to_id(new_name)
                            cmd_num = int(cmd_id)
                        except KeyError:
                            raise ValueError(f"Command {new_name} doesn't have a BDSP version!\n")

                        if warns_setting != 0:
                            warning_dict = bdsp_ref.commands[cmd_id].warning
                            if warning_dict:
                                if self.game in warning_dict:
                                    if warns_setting == 2:
                                        this_game_warning = warning_dict[self.game]
                                    elif warns_setting == 1:
                                        this_game_warning = ""
                                    else:
                                        raise ValueError(f"Invalid warns_setting '{warns_setting}'!\n")
                                    new_cmd_dict["WARNING"] = this_game_warning
                        
                        new_cmd_macro = {"CommandNo": cmd_num, "Name": new_name}
                        new_cmd_values = []

                        for arg in cmd.args:
                            if arg not in ("StartFrame", "EndFrame"):
                                new_arg_dict = {"Name": arg}
                                if isinstance(cmd.args[arg], list):
                                    new_arg_dict["Values"] = {"Array": [str(v)
                                                              for v in cmd.args[arg]]}
                                else:
                                    if arg in frame_params:
                                        cmd.args[arg] = round(cmd.args[arg]/2)

                                    new_arg_dict["Values"] = {"Array":
                                                              [str(cmd.args[arg])]}
                                    
                                new_cmd_values.append(new_arg_dict)

                        new_cmd_macro["Values"] = {"Array": new_cmd_values}
                        new_cmd_macro["CamFile"] = {"m_FileID": 0, "m_PathID": 0}

                        new_cmd_dict["Macro"] = new_cmd_macro

                        group_dict["Commands"]["Array"].append(new_cmd_dict)

                    group_data["Array"].append(group_dict)

            output_dict["_groupData"] = group_data

        ###################################
        #       Aldo's JSON format        #
        ###################################
        
        else:

            game_object_dict = {"m_FileID": 0, "m_PathID": 0}
            output_dict["m_GameObject"] = game_object_dict
            output_dict["m_Enabled"] = 1

            script_dict = {"m_FileID": 0, "m_PathID": 8754883562377533094}
            output_dict["m_Script"] = script_dict

            output_dict["m_Name"] = seq_name
            group_data = []
        
            
            for group in self.cmd_groups:
                if group.num_commands() > 0:

                    
                    
                    group_dict = {"Name": "", "GrpNo": group.num, "IsOpen": 1,
                                  "GrpDebug": 0, "BgColR": 0, "BgColG": 0, "BgColB": 0,
                                  "ColR": 0, "ColG": 0, "ColB": 0, "GrpOption": "",
                                  "GroupOption": []}

                    # Okay, now let's grab all the group options...
                    first_cmd = group.commands[0]
                    if opts_setting != 0:
                        for opt in first_cmd.opts:
                            if (opt[0:6] == "Option" and
                                (first_cmd.opts[opt] != 0 or opts_setting == 2)):
                                new_opt_dict = {}
                                num = int(opt[6:].strip())
                                new_opt_dict["Option"] = num
                                new_opt_dict["Value"] = first_cmd.opts[opt]
                                group_dict["GroupOption"].append(new_opt_dict)

                    # And now the actual commands.
                    group_dict["Commands"] = []

                    for cmd in group.commands:
                        
                        start_frame = cmd.opts["StartFrame"]
                        end_frame = cmd.opts["EndFrame"]

                        # LGPE and SwSh frame values are based on 60 FPS,
                        # but BDSP frame values are based on 30 FPS.
                        if self.game in ("SwSh, LGPE"):
                            start_frame = round(start_frame/2)
                            end_frame = round(end_frame/2)
                            
                        new_cmd_dict = {"StartFrame": start_frame,
                                        "EndFrame": end_frame,
                                        "ColR": 0, "ColG": 0, "ColB": 0,
                                        "Comment": "", "IsActive": 1}
                        
                        new_name = cmd.name.replace("Orion", "Old")

                        
                        
                        try:
                            cmd_id = bdsp_ref.name_to_id(new_name)
                            cmd_num = int(cmd_id)
                        except KeyError:
                            raise ValueError(f"Command {new_name} doesn't have a BDSP version!\n")

                        if warns_setting != 0:
                            warning_dict = bdsp_ref.commands[cmd_id].warning
                            if warning_dict:
                                if self.game in warning_dict:
                                    if warns_setting == 2:
                                        this_game_warning = warning_dict[self.game]
                                    elif warns_setting == 1:
                                        this_game_warning = ""
                                    else:
                                        raise ValueError(f"Invalid warns_setting '{warns_setting}'!\n")
                                    new_cmd_dict["WARNING"] = this_game_warning

                        
                        new_cmd_macro = {"CommandNo": cmd_num, "Name": new_name}
                        new_cmd_values = []

                        for arg in cmd.args:
                            if arg not in ("StartFrame", "EndFrame"):
                                new_arg_dict = {"Name": arg}
                                if isinstance(cmd.args[arg], list):
                                    new_arg_dict["Values"] = [str(v)
                                                              for v in cmd.args[arg]]
                                else:
                                    if arg in frame_params:
                                        cmd.args[arg] = round(cmd.args[arg]/2)

                                    new_arg_dict["Values"] = [str(cmd.args[arg])]
                                    
                                new_cmd_values.append(new_arg_dict)

                        new_cmd_macro["Values"] = new_cmd_values
                        new_cmd_macro["CamFile"] = {"m_FileID": 0, "m_PathID": 0}

                        new_cmd_dict["Macro"] = new_cmd_macro

                        group_dict["Commands"].append(new_cmd_dict)

                    group_data.append(group_dict)

            output_dict["_groupData"] = group_data
                
            

        return output_dict

